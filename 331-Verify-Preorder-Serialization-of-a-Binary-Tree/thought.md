### 331

这道题主要考查了二叉树的前序遍历，以及二叉树的结构。
这道题的大意是给定一个二叉树前序序列，然后要求判定该序列是不是正确的。

乍一看这是一道前序遍历的逆问题嘛，而且给定了'#'可以判定某一二叉树路径的结束，所以首先想到的就是尝试rebuild这棵二叉树，然后写了一个类似前序遍历递归，在读到'#'结束后直接返回，否则的话递归读取字符串的下一位置，并且传入左右子树的位置2*i+1,2*i+2,因为只考虑到了完全二叉树，所以这样表示错误，其实可以考虑建立链表来实现吧~但太复杂了，换思路。

然后通过观察容易发现对于给定的二叉树序列可以进行归约，即从左往右只要遇到`X##`形式的序列即可归约为一个'#'，然后继续归约直到只剩下一个'#'为止。其实这正是利用了前序遍历序列的性质，**先打印出了父节点，然后左子树和右子树依次跟在后面，将三者可以归约为一个节点**，继续向上归约，直到为'#'。具体实现用堆即可。

几个坑：

* 预处理问题。逗号分隔，不能直接用字符串，分割成list

* 考虑细节，1.n<3时，2.只有一个'#'元素时

* submit时的忽略情况：

  `1,#,#,#,#,....`，在`while`循环中连续归约时会越界。

  `#,#,#`，注意检测第一个元素为'#'且没读完时必定返回错误

  ​

其他更好的解法：利用二叉树的入度和出度 

> 在二叉树中，如果我们将空节点视为叶子节点，那么除根节点外的非空节点（分支节点）提供2个出度和1个入度（2个孩子和1个父亲） 所有的空节点提供0个出度和1个入度（0个孩子和1个父亲） 假如我们尝试重建这棵树。在构建的过程中，记录出度与入度之差，记为diff = outdegree - indegree 当遍历节点时，我们令diff - 1（因为节点提供了一个入度）。如果节点非空，再令diff + 2（因为节点提供了2个出度） 如果序列化是正确的，那么diff在任何时刻都不会小于0，并且最终结果等于0 

> 对该算法的一个朴素理解（2016-06-08增补）： 如果在遍历过程中的某时刻，系统的入度>出度，则说明当前序列中出现过的所有分支节点的“空闲分支”均已用完，后序节点没有办法挂载到之前出现的节点之上，从而判定先序遍历的序列是不合法的。

参考链接：https://leetcode.com/discuss/83824/7-lines-easy-java-solution（以上摘自ac）